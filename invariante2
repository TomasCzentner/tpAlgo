//Esto debería poder hacerse muchísimo más corto... 
//Seguro está mal. Revisar.
invariante actoresOrdenados: EstánActoresOrdenados(ActoresEnMin(actores(p)));

//Evalúa si la lista de actores está ordenada alfabeticamente
aux EstánActoresOrdenados(act: [Actor]) : Bool = {
	paratodos(i<-[1..|act|)) OrdenadasLexi(act[i-1],act[i]);
}

//Devuelve una lista de actores en minúsculas
aux ActoresEnMin(act [Actor]) : [Actor] = {
	[ [EnMinúsculas(x) | x <- y] | y <- act ];
}

aux EnMinúsculas(c: Char) : Char = {
	if ( (ord(c) >= ord('A')) && (ord(c) <= ord('Z')) )  then
		char(ord('a')+ord(c)-ord('A'));
	else
		c;
}

//Evalua si dos listas de char están ordenadas lexicográficamente 
aux OdenadasLexi(a,b : [Char]) : Bool = {
	if (|ÍndicesElemDist(a,b)| > 0) then
		ord(PrimerElemDist(a,b)) < ord(PrimerElemDist(b,a));
	else
		True;
}

//El primer valor de a distinto de b
//Requiere que existan elementos distintos entre a y b
aux PrimerElemDist(a,b: [T]) : T =
	índice( a, cab(ÍndicesElemDist(a,b));


//Una lista de los índices de los elementos distintos entre dos listas
aux ÍndicesElemDist(a,b: [T]): [Int] = {
	if |a| > |b| then 
		[ i | i<-[0..|a|), a[i] != b[i] ];
	else
		[ i | i<-[0..|b|), b[i] != a[i] ]
	
}

//Devuelve la lista más larga entre dos
//Irrelevante para esto, quién sabe si sirve de algo?
aux MásLarga(a,b: [T]): [T] = if |a| > |b| then [a] else [b];
